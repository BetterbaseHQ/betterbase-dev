# Encryption System Audit

**Status:** Audit complete, all actionable issues fixed
**Date:** 2026-02-13 (audit), 2026-02-13 (fixes)

---

## Purpose

This document audits the Less Platform's encryption system for correctness, standard compliance, and completeness. It covers every cryptographic primitive, every key derivation path, every wire format, and every key lifecycle — identifying what's solid, what needs attention, and what's missing.

The [Multiplayer Privacy Plan](./multiplayer-privacy-plan.md) focused on metadata minimization. The [System Privacy Audit](./system-privacy-audit.md) covered logging, timestamps, and operational privacy. This audit focuses exclusively on **cryptographic correctness**: are we using the right algorithms, the right parameters, the right key management patterns?

> **Pre-production system.** No deployed users, no migration constraints. Every fix can be made cleanly.

---

## Principles

1. **Use standard constructions** — AES-256-GCM, HKDF-SHA256, ECDSA P-256, AES-KW. No custom crypto.
2. **Defense in depth** — multiple independent layers, so a single compromise doesn't cascade.
3. **Forward secrecy** — compromise of today's key material doesn't expose yesterday's data.
4. **Minimize trust** — the server sees encrypted blobs, never plaintext. Keys never leave the client.
5. **Fail closed** — reject anything malformed. Prefer false negatives over silent corruption.

---

## Cryptographic Inventory

### Algorithms in Use

| Algorithm | Usage | Standard | Assessment |
|-----------|-------|----------|------------|
| AES-256-GCM | Record/file/membership encryption | NIST SP 800-38D | **Correct.** 256-bit keys, 96-bit random IVs, 128-bit tags. |
| AES-KW (256-bit) | DEK wrapping | RFC 3394 | **Correct.** 32-byte DEK → 40-byte wrapped output + 8-byte integrity check. |
| ECDSA P-256 | JWT signing, UCAN signing, membership signatures | FIPS 186-4 | **Correct.** IEEE P1363 format (64 bytes). |
| ECDH P-256 | JWE key agreement (invitations, scoped key delivery) | NIST SP 800-56A | **Correct.** ECDH-ES+A256KW via `jose` library. |
| HKDF-SHA256 | Epoch key derivation, mailbox ID derivation, key separation | RFC 5869 | **Correct.** Fixed domain-separation salt (ENC-1 resolved). |
| HMAC-SHA256 | Session tokens, rate limit hashing | RFC 2104 | **Correct.** Constant-time comparison everywhere. |
| OPAQUE (ristretto255) | Password authentication | RFC 9497 | **Correct.** Server never sees password. Fake records for enumeration resistance. |
| SHA-256 | Hash chain (membership log), UCAN CID, PKCE, refresh token storage | FIPS 180-4 | **Correct.** |
| UUID v4 | Record IDs | RFC 9562 | **Correct.** No timestamp leakage (switched from v7). |
| UUID v5 | Personal space IDs | RFC 9562 | **Correct.** Deterministic, cross-platform. |

### Key Sizes

| Key | Size | Standard? | Notes |
|-----|------|-----------|-------|
| AES-GCM encryption key | 256 bits | Yes | Maximum AES key size |
| AES-KW wrapping key (KEK) | 256 bits | Yes | Matches DEK size |
| DEK (per-record) | 256 bits | Yes | Random, never stored plaintext |
| ECDSA P-256 private key | 256 bits | Yes | Managed by Web Crypto (non-extractable where possible) |
| HMAC keys (session, rate limit) | 256 bits | Yes | `openssl rand -hex 32` |
| OPAQUE server key | 256 bits (ristretto255 scalar) | Yes | Generated by `keygen` tool |
| HKDF output | 256 bits | Yes | Matches key size |
| IV/nonce | 96 bits | Yes | NIST-recommended for AES-GCM |
| Auth tag | 128 bits | Yes | Maximum GCM tag size |

**Assessment:** All key sizes are at or above recommended minimums. No weak or non-standard sizes.

---

## Wire Formats

### Encrypted Record Blob (v4)

```
[1 byte: version=4][12 bytes: IV][N bytes: ciphertext + 16-byte auth tag]
```

Overhead: 29 bytes minimum. Version byte enables future format changes without breaking existing data.

**Assessment:** Clean, standard format. Version field is good practice.

### Wrapped DEK

```
[4 bytes: epoch (u32 BE)][40 bytes: AES-KW(KEK, DEK)]
```

Total: 44 bytes. The epoch prefix tells which KEK to use for unwrapping.

**Assessment:** Correct. The 40-byte AES-KW output is exactly right for a 32-byte input (adds 8-byte integrity check per RFC 3394).

### Session Token (sync server)

```
[1 byte: version][8 bytes: expiry][1 byte: permission][16 bytes: nonce][32 bytes: HMAC-SHA256]
```

Total: 58 bytes. HMAC covers `version || expiry || permission || nonce || spaceID`.

**Assessment:** Well-designed. Includes version for future extensibility, nonce for uniqueness, and space ID in HMAC prevents cross-space reuse.

### Membership Log Entry (encrypted)

```
AES-256-GCM(space_key, JSON({u, t, s, p, e?, m?, k?}), AAD=(spaceId, seq))
```

Hash chain over ciphertext: `entry_hash = SHA-256(ciphertext)`, `prev_hash` links to predecessor.

**Assessment:** Correct. Hash chain over ciphertext (not plaintext) means server can validate chain integrity without seeing content.

### BlobEnvelope (before encryption)

```
CBOR({c: collection, v: schema_version, crdt: bytes})
→ pad to bucket
→ AES-256-GCM(DEK, padded, AAD=(spaceId, recordId))
```

**Assessment:** Clean separation of concerns. CBOR is a good choice (compact, well-specified, no ambiguity).

---

## Key Derivation Paths

### 1. Epoch Key Chain (Forward Secrecy)

```
epoch_key_0 = OPAQUE_export_key (root) — or space key for shared spaces
epoch_key_{N+1} = HKDF-SHA256(
  ikm: epoch_key_N,
  salt: "less:epoch-salt:v1",
  info: "less:epoch:v1:{spaceId}:{N+1}"
)
```

**Assessment:** Forward-only derivation is correct — knowing epoch N derives N+1 but not N-1. The info string includes both space ID and epoch number for domain separation. Fixed domain-separation salt provides defense-in-depth (ENC-1 resolved).

### 2. Mailbox ID

```
mailbox_id = hex(HKDF-SHA256(
  ikm: encryption_key,          // 32 bytes from OPAQUE
  salt: "less-platform-mailbox-salt-v1",
  info: "less:mailbox:v1\0{issuer}\0{userId}"
))
```

**Assessment:** Correct. Null-byte delimiters prevent concatenation ambiguity. Fixed salt is acceptable because IKM has full entropy (OPAQUE export key).

### 3. Personal Space ID

```
personal_space_id = UUID5(
  namespace: UUID5(DNS, "less.so"),
  name: "{issuer}\0{userID}\0{clientID}"
)
```

**Assessment:** Deterministic and cross-platform. Null delimiters prevent ambiguity.

### 4. UCAN DID Key

```
did:key:z{base58btc(varint(0x1200) || compress_P256(pubkey))}
```

**Assessment:** Standard `did:key` encoding for P-256 (multicodec 0x1200). Matches the W3C DID specification.

### 5. Personal Space Key Separation

```
opaque_export_key (32 bytes from OPAQUE)
  → encryption_key = HKDF-SHA256(ikm: opaque_key, salt: "less:key-separation:v1", info: "less:encrypt:v1")
  → epoch_root_key = HKDF-SHA256(ikm: opaque_key, salt: "less:key-separation:v1", info: "less:epoch-root:v1")
```

**Assessment:** Correct. Separate keys derived for AES-GCM (record encryption in single-user mode) and AES-KW (epoch key wrapping). Eliminates multi-algorithm key reuse (ENC-6 resolved).

### 6. Scoped Key Delivery (JWE)

```
ECDH-ES+A256KW / A256GCM
  recipient: client's ephemeral P-256 public key
  bound to PKCE via: SHA256(code_verifier || jwk_thumbprint)
```

**Assessment:** Excellent. ECDH-ES provides forward secrecy for key delivery. Extended PKCE binding prevents key substitution. The ephemeral key is generated non-extractable and deleted after use.

---

## Issues Found

### ENC-1: Empty Salt in Epoch HKDF Derivation — RESOLVED

**Location:** `@betterbase/sdk/crypto` — `deriveNextEpochKey()`

**Was:** Empty salt (`new Uint8Array(0)`) in HKDF derivation.

**Fix:** Changed to fixed domain-separation salt: `utf8("less:epoch-salt:v1")`. This is a breaking change for epoch key derivation (acceptable pre-production). All epoch tests updated with new test vectors.

---

### ENC-2: Automatic Epoch Rotation Not Wired Up — RESOLVED

**Location:** `MultiSpaceTransport.pull()`, `SpaceManager.shouldRotateSpace()`, `SpaceManager.rotateSpaceKey()`

**Was:** `shouldAdvanceEpoch()` existed but was never called. No time-based rotation trigger.

**Fix:** Automatic epoch rotation wired up for **all spaces** (personal and shared):

- `SpaceManager.shouldRotateSpace(spaceId)` checks elapsed time vs. `DEFAULT_EPOCH_ADVANCE_INTERVAL_MS` (30 days). Only returns true for admins (prevents repeated 403 errors for non-admin members).
- `SpaceManager.rotateSpaceKey(spaceId)` performs full 3-step rotation: `advanceEpoch()` (server CAS sets `rewrap_epoch`) → `rewrapAllDEKs()` → `completeRewrap()` (server clears `rewrap_epoch`).
- `MultiSpaceTransport.pull()` checks all spaces after processing pull results, capped at `MAX_ROTATIONS_PER_PULL = 3` to avoid blocking sync after long offline periods.
- `epochAdvancedAt` tracked per space in the spaces collection. Legacy spaces without this field are backfilled to `Date.now()` on init.
- `onRotationError` callback on `MultiSpaceTransportConfig` for error reporting.
- CAS on `AdvanceEpoch` handles multi-device races — loser detects new epoch on next pull and re-derives.

See the [Automatic Key Rotation](#automatic-key-rotation-assessment) section for the full design rationale.

---

### ENC-3: File DEKs Not Re-wrapped on Key Rotation — RESOLVED

**Location:** `rewrapAllDEKs()` in `reencrypt.ts`, `removeMember()` in `space-manager.ts`

**Was:** The rewrap function re-wrapped record DEKs but not file DEKs. Revoked members could still decrypt files using the old KEK.

**Fix:** `rewrapAllDEKs()` accepts an optional `filesClient` parameter. After re-wrapping record DEKs, it fetches file DEKs via `filesClient.getFileDEKs()`, re-wraps them under the new epoch key, and uploads via `filesClient.rewrapFileDEKs()`. The `RewrapResult` includes `fileDekCount`. `SpaceManager.removeMember()` passes the `FilesClient` to `rewrapAllDEKs()`. Plaintext DEKs are zeroed after each re-wrap (ENC-11).

---

### ENC-4: `app-private-key` Stored as Extractable in IndexedDB (Medium — Inherent)

**Location:** `KeyStore.importAppPrivateKey()` in `key-store.ts`

**Current:**
```typescript
const key = await crypto.subtle.importKey(
  "jwk", jwk,
  { name: "ECDSA", namedCurve: "P-256" },
  true, // extractable
  ["sign"],
);
```

**Why:** The app private key needs to be extractable because it's used for both ECDSA signing and ECDH key agreement (for JWE decryption of invitations). Web Crypto requires exporting to JWK and re-importing with the ECDH algorithm to use the same key for both purposes.

**Impact:** An XSS attacker can call `crypto.subtle.exportKey("jwk", key)` and exfiltrate the private key. This allows them to:
- Sign UCANs as the user
- Decrypt invitation JWEs sent to the user
- Impersonate the user in ECDH key agreements

The encryption key (`AES-GCM`, non-extractable) and epoch key (`AES-KW`, non-extractable) cannot be exfiltrated this way.

**Analysis:** This is a fundamental limitation of Web Crypto's single-purpose key constraint. To use the same P-256 key for both ECDSA and ECDH, you must be able to export it. The alternatives are:

| Approach | Tradeoff |
|----------|---------|
| **Separate signing + encryption keys** | Doubles key management complexity. Inviter must encrypt to a different key than the one used for UCAN verification. Adds a second key to the key directory. |
| **Import as ECDH, derive signing key** | Not possible — ECDH keys can't sign in Web Crypto. |
| **Accept extractability** | Current approach. XSS exposure mitigated by short access token TTL (15 min) and CSP headers. |

**Recommendation:** Accept as inherent tradeoff for now. Document it. Revisit when/if separating signing and encryption keys becomes worthwhile (e.g., if adding key transparency where signing key pinning matters independently of encryption key).

**Priority:** Medium. Known tradeoff, not a bug.

---

### ENC-5: No Nonce-Misuse Resistance (Informational)

**Assessment:** AES-GCM is a standard choice, but it has a critical property: if a (key, nonce) pair is ever reused, confidentiality and authenticity are both catastrophically lost. The system relies on `crypto.getRandomValues()` for 96-bit nonces, giving a ~2^-32 collision probability after 2^32 encryptions under the same key.

**Mitigations already in place:**
- Per-record DEKs: Each record gets its own random 256-bit key. Nonce reuse can only happen within a single record's encryption history — not across records.
- This means the 2^32 birthday bound applies per-record, not per-space. A single record would need to be updated 4 billion times to approach the danger zone.

**Assessment:** The per-record DEK design effectively eliminates the nonce-misuse risk. No action needed.

**Alternative considered:** AES-GCM-SIV (nonce-misuse resistant). Unavailable in Web Crypto API. Would require a WASM dependency. Not justified given the per-record DEK mitigation.

**Priority:** Informational. Already effectively mitigated by envelope encryption.

---

### ENC-6: Same Raw Key Imported as Both AES-GCM and AES-KW — RESOLVED

**Location:** `AuthSession.create()` in `session.ts`, `hkdfDerive()` in `crypto.ts`

**Was:** Same 32-byte OPAQUE export key imported as both AES-GCM (encryption) and AES-KW (epoch wrapping).

**Fix:** `AuthSession.create()` now derives two separate keys via HKDF:
```typescript
const encKey = await hkdfDerive(authResult.encryptionKey, "less:encrypt:v1");
const epochKey = await hkdfDerive(authResult.encryptionKey, "less:epoch-root:v1");
```

Both derived keys and the original IKM are zeroed after import. The `hkdfDerive()` helper validates 32-byte IKM input. This is a breaking change for personal space data (acceptable pre-production).

---

### ENC-7: No Ciphertext Commitment (Low)

**Assessment:** AES-GCM is not committing — it's possible to construct a ciphertext that decrypts successfully under two different keys to two different plaintexts. This is relevant in protocols where a party might claim "I encrypted X" and later reveal a different key showing "actually it was Y."

**Relevance to Less Platform:** Low. The threat model is honest-but-curious server, not malicious participants trying to equivocate. The server never decrypts, so it can't exploit non-commitment. Between collaborators, the membership log with ECDSA signatures provides attribution.

**If needed later:** Add a commitment tag: `HMAC(key, ciphertext)` appended to each blob. This is ~32 bytes overhead per record.

**Priority:** Low. Not relevant to current threat model.

---

### ENC-8: UCAN Expiry Set to 1 Year — RESOLVED (Partial)

**Location:** `SpaceManager.createSpace()`, `SpaceManager.invite()`, `spaces.ts`

**Was:** Root and delegated UCANs expired after 365 days.

**Fix:** Reduced default UCAN lifetime to 90 days via `UCAN_LIFETIME_SECONDS` constant. Applied to both root UCANs (self-issued by space creator) and delegated UCANs (issued during invitation).

**Remaining:** Automatic UCAN renewal for delegated UCANs (requires delegator to be online) is not yet implemented. For root UCANs, renewal is trivial — the owner re-issues. Expired delegated UCANs currently require re-invitation.

---

### ENC-9: Membership Log Encrypted Under Single Space Key (Low)

**Location:** `encryptMembershipPayload()` in `membership.ts`

**Current:** All membership log entries are encrypted with the same space key (current epoch KEK). When the epoch rotates, new entries use the new key, but old entries remain encrypted under the old key.

After member revocation:
1. Old entries are re-appended encrypted under the new key ✓
2. The old ciphertext entries remain in the server's log (server doesn't delete old entries) — but the hash chain is rebuilt with new entries.

**Assessment:** This is correct for the current design. The server's hash chain is rebuilt during revocation. The old entries (encrypted under old key) are orphaned in the server's perspective — the chain no longer references them. The revoked member can still decrypt old entries (they had the old key), but this is inherent — they already saw the membership list while they were members.

**Priority:** Low. Working as designed.

---

### ENC-10: AAD Does Not Include Epoch (Informational)

**Current AAD format:**
```
[4 bytes: spaceId length (u32 BE)][spaceId UTF-8][recordId UTF-8]
```

The epoch is not included in AAD. This means a ciphertext encrypted under epoch N could theoretically be "replayed" in the context of epoch M (if someone had both keys).

**Analysis:** This is not exploitable because:
1. The DEK is wrapped under a specific epoch's KEK. Unwrapping the DEK inherently proves which epoch it belongs to.
2. The record blob is encrypted with the DEK, not the KEK. The epoch is bound via the DEK wrapping, not the blob encryption.
3. Including epoch in AAD would require re-encrypting all blobs on rotation (defeating the purpose of envelope encryption).

**Priority:** Informational. The binding is achieved through the DEK wrapping layer, not AAD.

---

### ENC-11: Plaintext DEK Not Zeroed After Use — RESOLVED

*Added by expert review.*

**Location:** `encryptEnvelope()` and `decryptEnvelope()` in `transport.ts`; `rewrapAllDEKs()` in `reencrypt.ts`

**Was:** Plaintext DEKs persisted in memory after use until GC collection.

**Fix:** `dek.fill(0)` added in `finally` blocks in both `encryptEnvelope()` and `decryptEnvelope()`, ensuring DEKs are zeroed even if encryption/decryption throws. Same pattern applied in `rewrapAllDEKs()` for both record and file DEK re-wrapping loops, plus a `try/finally` that zeroes all intermediate epoch keys in the key cache. This matches the zeroing pattern already used in `KeyStore.importEncryptionKey()`.

---

### ENC-12: Epoch Advance + DEK Re-wrap Is Non-Atomic — RESOLVED

*Added by expert review.*

**Location:** `reencrypt.ts` (`advanceEpoch`, `rewrapAllDEKs`), `space-manager.ts`, `less-sync/storage/postgres.go`

**Was:** If crash/network failure occurred between epoch advance (CAS) and DEK re-wrap upload, the space was left in an unrecoverable state. The original basic fix used a client-side `pendingRewrap` flag, but this had a fundamental problem: the flag was set before the server CAS succeeded, and only existed on the initiating device — other devices had no way to discover or complete an interrupted rewrap.

**Fix:** Replaced client-side `pendingRewrap` with server-side `rewrap_epoch` column. The server is now the single source of truth for rotation state:

1. `POST /epoch/begin` atomically sets `key_generation = N` and `rewrap_epoch = N` (CAS guard: fails if `rewrap_epoch` is already set)
2. Client fetches all DEKs, unwraps with old key, re-wraps with new key, uploads
3. `POST /epoch/complete` clears `rewrap_epoch` (CAS on epoch value)

**Recovery:** Any admin who pulls discovers `rewrap_epoch` in the `pull.begin` CBOR frame. They derive the appropriate key via `deriveForward()`, complete the rewrap (idempotent — `peekEpoch` skips already-rewrapped DEKs), and call `completeRewrap()`. The server rejects further epoch advances while `rewrap_epoch` is set.

**Server-side validation:** `RewrapDEKs` validates that every uploaded DEK's epoch prefix (first 4 bytes, big-endian u32) matches `key_generation`. This prevents a stale client from uploading DEKs wrapped under a wrong epoch.

**Structured errors:** 409 responses include `{current_epoch, rewrap_epoch}` so the client can distinguish "concurrent advance" from "rewrap incomplete" and handle each case appropriately.

**Removed:** Client-side `pendingRewrap` field, `resumeRewrap()` method, `MAX_RESUME_DISTANCE` guard. The old `/rotate-key` endpoint was unified into `/epoch/begin` with an optional `set_min_key_generation` flag (for revocation).

---

### ENC-13: JWK Thumbprint Does Not Validate Required Fields — RESOLVED

*Added by expert review.*

**Location:** `computeJwkThumbprint()` in `@betterbase/sdk/auth` `crypto.ts`

**Was:** If any JWK field was `undefined`, `JSON.stringify` would silently drop it, producing a non-compliant thumbprint.

**Fix:** Added two-phase validation: first checks `kty !== "EC"` with a clear error message, then checks individual EC fields (`crv`, `x`, `y`) separately. Fails fast with descriptive errors before thumbprint computation.

---

### ENC-14: No Key Transparency or Identity Verification (Future Consideration)

*Added by expert review.*

**Assessment:** Signal has key transparency (safety numbers, key fingerprints). Matrix has cross-signing and device verification. Less Platform has neither — the UCAN chain provides authorization (who can access what), but there's no mechanism for users to verify they're encrypting to the right person.

In a shared space, when Alice invites Bob, she looks up Bob's public key from the accounts server. If the accounts server is compromised, it could substitute a different public key, enabling a MITM attack on the invitation JWE.

**Current mitigation:** The accounts server is trusted for identity (this is the honest-but-curious model). The TOFU key pinning mentioned in the multiplayer privacy plan would add basic change detection.

**Recommendation:** Not blocking for launch. After launch, implement TOFU key pinning (already planned) as a first step, then consider a key transparency log for stronger guarantees.

**Priority:** Future consideration. Document as known limitation.

---

## What's Solid

These areas are well-implemented and need no changes:

### Envelope Encryption
The per-record DEK pattern is correctly implemented. Each record gets a random 256-bit DEK, encrypted with AES-256-GCM with proper AAD binding. DEKs are wrapped with AES-KW under the epoch KEK. Key rotation is O(n × 44 bytes), not O(n × data_size). This is the same pattern used by AWS SSE, Google Tink, and Signal.

### OPAQUE Authentication
The server never sees passwords. Fake OPAQUE records prevent username enumeration with timing-safe responses. OPRF seeds are per-account. The implementation uses the standard `ristretto255` group.

### JWE Key Delivery
ECDH-ES+A256KW with A256GCM is the right choice. Extended PKCE binds the ephemeral key to the authorization code. The ephemeral private key is generated non-extractable and deleted after use.

### UCAN Chain Validation
The sync server validates full chains with:
- Signature verification at every level
- Attenuation enforcement (child ≤ parent permission)
- Expiry propagation (child ≤ parent expiry)
- Delegation binding (`proof.aud == current.iss`)
- Root key matching (constant-time comparison against `root_public_key`)
- Revocation checking
- Nonce requirement (prevents pre-signed token reuse)
- Max depth (8) and max tokens (32) limits

### Web Crypto Key Protection
Encryption keys and epoch keys are stored as non-extractable `CryptoKey` objects in IndexedDB. Even XSS cannot exfiltrate the raw key bytes. (The app private key is extractable — see ENC-4 — but this is an inherent Web Crypto limitation.)

### Server-Side Zero Knowledge
The sync server never decrypts blobs. It stores opaque ciphertext, validates UCAN chains ephemerally (in memory), and issues opaque session tokens. The membership log is encrypted. File content is encrypted.

### Session Token Design
HMAC-SHA256 with version, expiry, permission level, nonce, and space ID binding. Constant-time comparison. 15-minute TTL. No user identity stored in the token.

### Hash Chain Integrity
The membership log uses a hash chain over ciphertext (`entry_hash = SHA-256(ciphertext)`, `prev_hash` links entries). The server validates chain integrity without seeing plaintext. ECDSA P-256 signatures on every entry provide non-repudiation.

---

## Automatic Key Rotation: Assessment

### Current State

| Trigger | Implemented? | Notes |
|---------|-------------|-------|
| Member revocation | **Yes** | `removeMember()` → `advanceEpoch(setMinKeyGeneration)` → `rewrapAllDEKs()` → `completeRewrap()` |
| Time-based (30 days) | **Yes** | `MultiSpaceTransport.pull()` → `shouldRotateSpace()` → `rotateSpaceKey()` for all spaces (personal + shared). Admin-only check prevents non-admin 403 errors. Capped at 3 rotations per pull. |
| Password change | **Partial** | OPAQUE re-registration changes root key, but doesn't propagate to spaces |
| Manual admin action | **No** | No UI or API for explicit rotation |

### Decision: Automatic Rotation for All Spaces

**Rotate all spaces — personal and shared — on the same 30-day schedule.**

The original draft recommended skipping personal spaces ("if the attacker has your device they have everything"). That reasoning was wrong for three reasons:

**1. The marginal cost is near-zero.** If we're building bulletproof rotation for shared spaces (crash recovery via ENC-12, file DEKs via ENC-3, CAS coordination), personal spaces use the exact same code path. The only difference is coordination complexity — and personal spaces are simpler (single device always wins the CAS). There's no separate "personal space rotation" to build. It's just `advanceEpoch()` → `rewrapAllDEKs()` → `completeRewrap()`.

**2. The common path tests the hard path.** Personal spaces are the most frequent case — every user has one, many users have only one. If rotation runs there on every 30-day cycle, we exercise the full machinery (derive key → advance epoch → fetch DEKs → re-wrap → upload) constantly. Bugs surface in the easy case (single user, no coordination) before they matter in the hard case (shared space revocation under time pressure). If rotation is conditional, the first time it runs in a shared space might be during a security-critical revocation — the worst time to discover a bug.

**3. Forward secrecy protects against more than device theft.** A leaked backup, a compromised cloud sync snapshot, an exported IndexedDB dump, a stolen database backup on the server — these are all partial key compromises where the attacker gets a point-in-time KEK but not ongoing access. Without rotation, that KEK decrypts all future records in the space forever. With 30-day rotation, it decrypts at most 30 days of future data. This applies equally to personal and shared spaces.

**4. Predictability.** If rotation always runs, it's just how the system works. No configuration, no "we forgot to enable it," no conditional code paths. Every space rotates. Period.

### Recommended Implementation

**Trigger point:** During `MultiSpaceTransport.pull()` for all spaces (personal and shared).

```
On pull (any space):
  1. If pull.begin has rewrap_epoch AND this device is admin:
     a. Derive key forward to rewrap_epoch via deriveForward()
     b. rewrapAllDEKs() (idempotent — skips DEKs already at target epoch)
     c. completeRewrap() (server clears rewrap_epoch)
     d. Update local state (epoch, key, epochAdvancedAt)
  2. If pull.begin has key_generation > local AND no rewrap_epoch:
     a. Derive key forward to server epoch via deriveForward()
     b. Update local state (adopt new epoch)
  3. Check shouldRotateSpace() for this space:
     a. If true: advanceEpoch() (server CAS sets rewrap_epoch)
     b. rewrapAllDEKs() (record DEKs + file DEKs — ENC-3)
     c. completeRewrap() (server clears rewrap_epoch)
     d. Update local state
  4. On EpochMismatchError (another device won the CAS):
     a. If rewrap_epoch set: help complete interrupted rewrap (step 1)
     b. If no rewrap_epoch: adopt new epoch (step 2)
```

**Why on pull (not push):**
- Pull is more frequent than push (WS-triggered).
- Rotation before a push would add latency to user-visible write operations.
- The CAS ensures only one device rotates; others adopt.

**Multi-device coordination:**
- Device A calls `advanceEpoch(epoch=N+1)` — server CAS: `WHERE key_generation = N AND rewrap_epoch IS NULL`.
- If device B also tries, it gets `ErrEpochMismatch`.
- Device B detects the new epoch on its next pull (`pull.begin` frame includes `key_generation`).
- Device B derives the new epoch key from its root key and continues.

**Key propagation:**
- **Personal spaces:** The OPAQUE-derived encryption key is the root. `deriveEpochKeyFromRoot(rootKey, spaceId, newEpoch)` chains forward. All devices sharing the same OPAQUE key derive the same epoch keys.
- **Shared spaces:** The space key (shared via invitation JWE) is the root. All members derive the same epoch keys from it. No key exchange needed on rotation.

---

## Summary of Findings

### Resolved

| ID | Issue | Resolution |
|----|-------|------------|
| **ENC-1** | Empty HKDF salt in epoch derivation | Fixed. Domain-separation salt `"less:epoch-salt:v1"`. |
| **ENC-2** | Automatic epoch rotation not wired up | Fixed. Runs for all spaces on pull, admin-only, capped at 3/pull. |
| **ENC-3** | File DEKs not re-wrapped on key rotation | Fixed. `rewrapAllDEKs()` re-wraps both record and file DEKs. |
| **ENC-6** | Same key for AES-GCM and AES-KW in personal spaces | Fixed. Separate keys derived via HKDF from OPAQUE export key. |
| **ENC-8** | UCAN expiry at 365 days | Partially fixed. Reduced to 90 days. Automatic renewal for delegated UCANs not yet implemented. |
| **ENC-11** | Plaintext DEK not zeroed after use | Fixed. `dek.fill(0)` in `finally` blocks in encrypt/decrypt/rewrap paths. |
| **ENC-12** | Non-atomic epoch advance + DEK re-wrap | Fixed. Server-side `rewrap_epoch` column as source of truth. Any admin discovers and completes interrupted rewraps via pull. DEK epoch validation on server. |
| **ENC-13** | JWK thumbprint doesn't validate required fields | Fixed. Two-phase validation (kty check, then EC field check). |

### Accepted Tradeoffs (Informational)

| ID | Issue | Why Accepted |
|----|-------|-------------|
| **ENC-4** | App private key extractable in IndexedDB | Web Crypto limitation — needed for both ECDSA and ECDH. This is the highest-value XSS target; CSP headers (INFRA-5) are the primary mitigation. |
| **ENC-5** | No nonce-misuse resistance (AES-GCM) | Per-record DEKs eliminate practical nonce reuse risk. |
| **ENC-7** | No ciphertext commitment | Not relevant to honest-but-curious threat model. |
| **ENC-9** | Membership log under single space key | Working as designed; old entries re-appended on rotation. |
| **ENC-10** | AAD doesn't include epoch | Binding achieved through DEK wrapping layer. |
| **ENC-14** | No key transparency / identity verification | Accounts server is trusted for identity. TOFU key pinning planned as first step. |

---

## Comparison to Reference Systems

| Property | Less Platform | Signal | Matrix (Megolm) | Apple iCloud |
|----------|--------------|--------|-----------------|-------------|
| **Record encryption** | AES-256-GCM + per-record DEK | AES-256-CBC + HMAC per message | AES-256-CTR + HMAC-SHA256 per message | AES-256-GCM (selected services) |
| **Key wrapping** | AES-KW (256-bit KEK) | N/A (per-message keys) | AES-256 (session key) | AES-KW (service key) |
| **Forward secrecy** | HKDF epoch ratchet (30-day) | Double Ratchet (per-message) | Hash ratchet (per-message) | No (static key hierarchy) |
| **Key exchange** | ECDH P-256 via JWE | X3DH (Curve25519) | Olm (Curve25519) | ECDH P-256 |
| **Nonce reuse risk** | None (per-record DEK) | None (per-message key) | Low (counter mode) | Standard GCM risk |
| **Auth/signing** | ECDSA P-256 + UCAN | Ed25519 + sealed sender | Ed25519 | RSA-2048 / ECDSA |
| **Password auth** | OPAQUE (ristretto255) | PAKE (Signal PIN) | N/A (no passwords) | SRP-6a |
| **Key transparency** | None (TOFU planned) | Safety numbers | Cross-signing | N/A |

**Assessment:** Less Platform's encryption is on par with Signal and Matrix for data confidentiality. Both Less Platform and Signal achieve the same nonce-safety goal (unique key per encryption operation) via different mechanisms — per-record DEKs vs. per-message key derivation. The engineering tradeoff differs: persistent DEKs require wrapping/management; ephemeral keys are derived and discarded.

The main gap vs. Signal is **forward secrecy granularity**: Signal achieves per-message forward secrecy via the Double Ratchet, while Less Platform achieves per-epoch (30-day) forward secrecy. This is a deliberate tradeoff — the sync protocol requires any member to decrypt any record at any time (not just new messages in order), which is incompatible with per-message ratcheting. The 30-day epoch is a reasonable compromise for the productivity app use case. Automatic 30-day rotation is now wired up for all spaces (ENC-2 resolved).

The remaining gap is **key transparency**: Signal has safety numbers for verifying contact identity, Matrix has cross-signing for device verification. Less Platform has neither — the UCAN chain provides authorization but not identity verification. TOFU key pinning (already planned) addresses the most common attack (key substitution by compromised accounts server). A full key transparency log would provide stronger guarantees but is not essential for the target use cases (productivity apps, not whistleblowing).

---

## Implementation Priority

All actionable issues have been addressed. Remaining work:

### Done
1. ~~**ENC-1: HKDF salt**~~ — Fixed. Domain-separation salt.
2. ~~**ENC-2: Automatic rotation**~~ — Fixed. All spaces, on pull, admin-only.
3. ~~**ENC-3: File DEK re-wrapping**~~ — Fixed. Record + file DEKs.
4. ~~**ENC-6: Key separation**~~ — Fixed. HKDF-derived separate keys.
5. ~~**ENC-8: UCAN lifetime**~~ — Reduced to 90 days.
6. ~~**ENC-11: DEK zeroing**~~ — Fixed. `finally` blocks.
7. ~~**ENC-12: Crash recovery**~~ — Fixed. Server-side `rewrap_epoch` + multi-device recovery.
8. ~~**ENC-13: JWK validation**~~ — Fixed. Two-phase validation.

### Remaining
- **ENC-8 (partial):** Automatic UCAN renewal for delegated UCANs (requires delegator online).
- **ENC-14:** Key transparency / TOFU key pinning (future consideration).

---

## Expert Review Summary

**Reviewer:** Subject-matter expert in applied cryptography and E2EE systems
**Date:** 2026-02-13

**Overall Assessment:** The encryption system uses standard, well-vetted constructions throughout. No novel cryptography. No weak algorithms. Key sizes are all at or above recommended minimums. The per-record DEK envelope encryption pattern is correctly implemented and provides strong nonce-misuse resistance.

**Key Findings (all addressed):**
1. ENC-3 confirmed as a correctness bug (file DEKs not rotated) — **fixed**
2. ENC-12 identified: non-atomic epoch advance + re-wrap creates a crash-recovery gap — **fully resolved via server-side `rewrap_epoch`**
3. ENC-11 identified: DEK bytes not zeroed after use — **fixed**
4. ENC-13 identified: JWK thumbprint computation should validate inputs — **fixed**
5. ENC-14 identified: key transparency gap vs. Signal/Matrix (future consideration)
6. Comparison to Signal corrected: both systems achieve equivalent nonce safety; the tradeoff is engineering, not security
7. All severity ratings confirmed as accurate

**Characterization:** Solid foundation. All actionable issues from the initial audit have been resolved. The cryptographic primitives, key hierarchy, wire formats, and operational patterns (automatic rotation, crash recovery, DEK zeroing) are production-ready. The epoch advancement system uses server-side `rewrap_epoch` as the single source of truth, enabling multi-device crash recovery and eliminating the two-state-machine desync problem. Remaining items are future enhancements: UCAN auto-renewal and key transparency.
